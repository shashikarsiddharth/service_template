"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.update = void 0;
const child_process_1 = require("child_process");
const path_1 = require("path");
const fast_glob_1 = __importDefault(require("fast-glob"));
const fs_extra_1 = require("fs-extra");
exports.update = async () => {
    console.log("Updating...");
    let repoUrl = process.argv[2];
    if (!repoUrl)
        throw new Error("Provide a repository URL");
    if (!repoUrl.includes("@") && !repoUrl.includes("//"))
        repoUrl = `https://github.com/${repoUrl}`;
    // If this is running in a Github Actions workflow, we know the repo name
    let [owner, repo] = (process.env.GITHUB_REPOSITORY || "").split("/");
    if (owner && repo)
        if (repoUrl === `https://github.com/${owner}/${repo}`)
            return console.log("Skipping updating same repo");
    const tempDir = `tempDir_${Math.random().toString(32).split(".")[1]}`;
    child_process_1.execSync(`git clone ${repoUrl} ${tempDir}`);
    let config = {};
    try {
        config = await fs_extra_1.readJson(path_1.join(".", tempDir, ".templaterc.json"));
    }
    catch (error) {
        console.log(".templaterc.json config file not found");
    }
    const files = (await fast_glob_1.default((config.files || []).map((glob) => `${tempDir}/${glob}`))).map((file) => file.substring(tempDir.length));
    for await (const file of files) {
        await fs_extra_1.ensureFile(path_1.join(".", file));
        await fs_extra_1.copyFile(path_1.join(".", tempDir, file), path_1.join(".", file));
    }
    if (config.npmDependencies) {
        const templatePackageJson = await fs_extra_1.readJson(path_1.join(".", tempDir, "package.json"));
        const localPackageJson = await fs_extra_1.readJson(path_1.join(".", "package.json"));
        const dependencies = {
            ...localPackageJson.dependencies,
            ...templatePackageJson.dependencies,
        };
        const ordered = {};
        Object.keys(dependencies)
            .sort()
            .forEach((key) => (ordered[key] = dependencies[key]));
        localPackageJson.dependencies = ordered;
        await fs_extra_1.writeFile(path_1.join(".", "package.json"), JSON.stringify(localPackageJson, null, 2) + "\n");
    }
    if (config.npmScripts) {
        const templatePackageJson = await fs_extra_1.readJson(path_1.join(".", tempDir, "package.json"));
        const localPackageJson = await fs_extra_1.readJson(path_1.join(".", "package.json"));
        const scripts = {
            ...localPackageJson.scripts,
            ...templatePackageJson.scripts,
        };
        const ordered = {};
        Object.keys(scripts)
            .sort()
            .forEach((key) => (ordered[key] = scripts[key]));
        localPackageJson.scripts = ordered;
        await fs_extra_1.writeFile(path_1.join(".", "package.json"), JSON.stringify(localPackageJson, null, 2) + "\n");
    }
    config.removeFiles = config.removeFiles || [];
    config.removeFiles = [...config.removeFiles, ".templaterc.json"];
    console.log(config.removeFiles);
    const filesToDelete = await fast_glob_1.default(config.removeFiles);
    for await (const file of filesToDelete) {
        await fs_extra_1.remove(path_1.join(".", file));
    }
    await fs_extra_1.remove(path_1.join(".", tempDir));
};
//# sourceMappingURL=update.js.map